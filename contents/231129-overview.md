# Compiler Overview 🤿

개발자는 C, C++, Swift 등의 고급언어를 사용하여 비교적 쉽게 프로그램을 작성하고 이렇게 작성된 프로그램을 컴퓨터에서 실행함으로써 원하는 작업을 컴퓨터로 처리합니다.

그러나 고급언어로 작성된 프로그램들은 **기계어**가 아니므로 컴퓨터에서 직접 실행할 수 없기 때문에 **컴파일러**가 이 프로그램들을 번역하여 컴퓨터가 실행할 수 있는 **기계어**로 변환 시켜주어야 합니다.

따라서 하나의 프로그램 언어가 출시되었다는 것은 그것을 번역하는 컴파일러가 만들어졌다는 뜻이 됩니다.

컴파일러를 직접 구현하는 일은 매우 어렵습니다.

초기 언어인 FORTRAN 언어에서 컴파일러를 구현하기 위하여 18년이 소요된 사실만 보아도 하나의 컴파일러를 구현하는 것이 얼마나 어려운 일인지 짐작할 수 있습니다.

이를 해결하기 위하여 컴파일러를 설계하고 구현하는 방법에 대하여 오랫동안 연구가 진행되어 왔습니다.

<img src = "https://github.com/devKobe24/images/blob/main/CPDD-1.png?raw=true"></br>

# 1️⃣ 컴파일러의 필요성.

컴퓨터 언어 중에서 어떤 문제를 풀기 위해 일련의 과정을 기술하는 데 사용되는 언어를 **프로그래밍 언어(Programming language)** 라고 합니다.

컴퓨터는 0과 1로 구성된 2진법 수만 취급하므로 초기의 프로그래밍 언어는 0과 1로 작성된 **기계어(Machine language)** 였습니다.

명령어를 0과 1로 나타낸다는 것이 매우 불편했고, 컴퓨터의 하드웨어 특성과 동작과정을 잘 알아야 하기 때문에 매우 어려웠습니다.

따라서 조금 더 편리한 프로그래밍 언러를 생각하게 되었는데, 그것이 **어셈블리어(assembly language)** 입니다.

어셈블리어는 0과 1로 구성된 명령어 대신에 A(ADD), L(LOAD) 등과 같이, 그에 대응하는 기호를 사용함으로써 불편한 프로그래밍 작업을 완화시켜 주었습니다.

> 📝 NOTE
> 
> 어셈블리어로 작성된 프로그램을 입력 => 어셈블러가 번역 => 기계어로 작성된 프로그램을 출력.

**그러나** 어셈블리어도 기계어 대신 기호를 사용한다는 것뿐이지 결국은 기계어 처리방식을 알아야 하므로 프로그래밍하기가 매우 어려웠습니다.

**이에 영어와 유사한 고급언어를 만들게 되었습니다.**

고급언어로 작성된 프로그램은 기계가 이해할 수 있는 기계어로 다시 바꾸어 주어야 합니다.
즉, **번역기(translator)** 가 번역을 해 주어야 합니다.

**번역기**란 이처험 하나의 프로그래밍 언어로 작성된 프로그램을 입력으로 하여, 그와 동등한 의미를 갖는 다른 프로그래밍 언어로 된 프로그램을 출력하는 하나의 프로그램입니다.

이때 **입력**되는 프로그램을 **원시 프로그램(Source program)** 라 합니다.
또한 **출력**되는 프로그램을 **목적 프로그램(Object program)** 이라 하고, 이 프로그램을 기술한 **언어**를 **목적언어(Object language, target language)** 라 합니다.

번역기의 종류를 살펴보면 어셈블러, 컴파일러, 프리프로세서(preprocessor), 인터프리터(interpreter) 등이 있는데, 이 중 가장 대표적인 번역기가 **컴파일러**입니다.

**어셈블러**란 어셈블리어로 작성된 프로그램을 그에 대응하는 기계어로 번역해 주는 번역기입니다.
**컴파일러**는 원시언어가 C, C++ 등의 고급언어이고 목적언어가 저급언어인 경우를 말하는데, 여기서 저급언어란 어셈블리어나 기계어를 뜻합니다.
예를 들어, 원시언어가 C이면 C 컴파일러라고 하고, 원시언어가 C++ 이면 그 컴파일러를 C++ 컴파일러라고 합니다.

<img src = "https://github.com/devKobe24/images/blob/main/CPDD-2.png?raw=true"></br>

일반적으로 모든 컴퓨터에는 **어셈블러**가 있습니다.

따라서 컴파일러는 작업을 효율적으로 하기 위하여 원시 프로그램을 기계어로 작성된 프로그램으로 번역을 하는 것이 아니라, 원시 프로그램을 어셈블리어로 작성된 프로그램으로 번역을 합니다.

그러면 **어셈블리어**가 이를 **기계어** 프로그램으로 번역을 해줍니다.

따라서 **컴파일러**에게 기계어 프로그램으로 번역하는 기능을 제외할 수 있으므로 컴파일러를 제작하기가 훨씬 더 수월해집니다.

**프리프로세서(preprocessor)** 는 프로그래밍 언어에 유용한 기능을 추가하여 언어를 확장시켜 주는 역할을 하는 것으로, 원시언어와 목적언어가 모두 고급언어인 번역기를 말합니다.

<img src = "https://github.com/devKobe24/images/blob/main/CPDD-3.png?raw=true"></br>

**프리프로세서**의 예로는 C 언어를 들 수 있습니다.

C 언어는 자체적으로 프리프로세서 기능을 갖고 있어서 사용자로 하여금 쉽게 언어를 확장할 수 있게 해 줍니다.

C 언어에서 제공하는 프리프로세서는 세 가지 입니다.

먼저, 표제 파일(header file)과 같은 파일을 포함하여 **언어를 확장해 주는 기능**이 있습니다.

그 다음으로는 **매크로 치환**입니다.
이는 프로그램에서 자주 사용되는 상숫값이나 식을 간단한 심벌 이름으로 대치하여 반복 사용하는 불편을 줄이고 프로그램의 의미와 관련된 심벌을 등장시켜 언어를 확장하는 방법입니다.

<img src = "https://github.com/devKobe24/images/blob/main/CPDD-4.png?raw=true"></br>

마지막으로 **조건 번역**입니다.
주어진 조건에 따라 프리프로세서 프로그램을 선택하는 기능입니다.

<img src = "https://github.com/devKobe24/images/blob/main/CPDD-5.png?raw=true"></br>

**인터프리터**는 앞의 번역기와는 달리 번역과 동시에 실행하게 됩니다.
즉, 고급언어를 입력으로 받아들여서 번역과 동시에 실행한 후, 그 결과를 출력하기 때문에 APL, SNOBOL 등과 같은 대화용 언어를 구현할 때 사용합니다.

결론적으로 컴파일러와 인간의 의사전달을 위해서는 고급언어가 필요하고, 고급언어로 작성된 프로그램을 컴퓨터가 인식할 수 있도록 기계어로 번역해 주어야 하므로 컴파일러가 필요합니다.

**컴파일러는 목적코드에 따라 다음과 같이 구분할 수 있습니다.**

**1️⃣ 네이티브 컴파일러(native compiler)**
일반적으로 사용하는 컴파일러입니다.
즉, 컴파일러가 하나의 컴퓨터에서 실행된 후 목적코드를 생산하고나면 그 목적코드는 바로 그 컴퓨터에서 실행이 됩니다.
이런 경우를 네이티브 컴파일러라고 합니다.
물론 여기서 컴퓨터에서 실행되려면 그 컴퓨터가 사용하는 운영체제에서 실행된다는 뜻을 포함하고 있습니다.

**2️⃣ 크로스 컴파일러(cross compiler)**
임베디드 프로그램처럼 목적코드가 다른 컴퓨터나 운영체제에서 실행되도록 번역합니다.

**3️⃣ 바이트코드 컴파일러**
JAVA 언어가 대표적인 예입니다.
자바 컴파일러는 원시 프로그램을 자바 바이트코드 형태로 번역합니다.
바이트코드는 자바 가상 머신(java virtual machine)에서 실행될 수 있는 코드입니다.
따라서 자바는 컴퓨터의 하드웨어에 상관없니 자바 가상 머신이 설치된 컴퓨터에서는 모두 실행되므로 이식성이 높습니다.
