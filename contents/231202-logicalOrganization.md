# 컴파일러의 논리적 구조 🧑‍💻.

**컴파일러는 고급언어로 쓰인 원시 프로그램을 입력으로 받아서, 컴퓨터에서 직접 실행 가능한 형태의 목적 프로그램을 출력으로 내보내 주는 컴퓨터 프로그램입니다.**

이러한 컴파일러 구조는 **논리적 구조(logical organization)**, **구현과 관련된 물리적인 구조**로 분류하여 생각할 수 있습니다.

먼저, 컴파일러의 논리적 구조를 살펴보기 전에 컴파일러가 문장을 읽어 들인 후 어떠한 과정을 거쳐 목적 프로그램을 만드는지에 대해 생각해봅시다.

## 1️⃣ 컴파일러가 목적 프로그램을 만드는 과정.

예를 들어 영어를 해석하는 경우를 생각해 볼 수 있습니다.

다음 영어 문장을 봅시다.

**"I am a boy."**

이 문장에 대해 누구나 "나는 소년이다."라고 쉽게 해석할 수 있을 것입니다.
그런데 구체적으로 어떠한 과정을 거쳐 번역을 했는지 분석해 보면 컴파일러의 기능을 이해하는 데 도움이 됩니다.
**왜냐하면 컴파일러 또한 하나의 번역기이기 때문입니다.**

그 번역과정은 대체로 다음과 같습니다.

### 첫째, 단어 또는 어휘분석.

단어 **I, am, a, boy** 하나하나에 대하여 그 단어가 올바른 단어인지를 분석합니다.

### 둘째, 문장 또는 구문분석.

문장은 다음과 같이 분석할 수 있습니다.

**문장의 흐름: => "I == 주어", "am == 동사", "a boy == 보어"**

이로 인해서 이 문장은 문법에 맞는 올바른 구문임을 알 수 있습니다.

### 셋째, 해석 또는 의미분석.

단어가 올바르고 문장구문도 올바르므로 해석을 해 주면 됩니다.

---

지금까지 사람의 입장에서 영어를 해석(번역)하는 과정을 살펴보았습니다.

컴파일러 역시 프로그램 언어를 입력으로 받아들여서 번역을 하는 번역기이므로 바로 이러한 과정을 거칩니다.

**컴파일러의 경우는 다음과 같이 대응되고 해석된 내용을 컴퓨터가 처리할 수 있는 코드로 변환하는 과정이 하나 더 있다고 할 수 있습니다.**

<img src = "https://github.com/devKobe24/images/blob/main/CPDD-9.png?raw=true"></br>

컴파일러의 **논리적 구조**를 살펴보면 아래 그림과 같이 **여섯 개의 단계**로 나누어 볼 수 있습니다.

<img src = "https://github.com/devKobe24/images/blob/main/CPDD-10.png?raw=true"></br>

각 단계들은 한 프로그램을 어떤 다른 형태로 변형시키지만, 이 중 일부 단계는 하나로 합칠 수 있습니다.

여기서 **기호표(symbol table)관리** 와 **오류처리(error handler)** 기능은 6단계 모두에서 상호작용을 합니다.

각 단계별로 기능을 살펴보면 다음과 같습니다.

## 2️⃣ 캄파일러의 논리적 구조 6단계

### 1. 어휘분석(lexical analysis) 단계.

**어휘분석 단계에서는 원시 프로그램을 읽어 들여서 프로그램 문장을 구성하고 있는 최소 단위인 어휘들을 떼어 내어 이 어휘들이 올바른지 분석하는 일을 합니다.**

따라서 모든 어휘를 정의한 문법(grammar)이 필요합니다.

**어휘분석 단계**에서 **어휘**들은 이들을 정의한 해당 문법에 의하여 **분석**되는데 어휘가 올바르지 않으면 **오류메시지(error message)** 가 출력되고, 올바른 경우는 **토큰(token)** 형태로 **출력**됩니다.

따라서 **어휘**, **토큰**은 의미 있는 **최소의 문법적 단위(syntactic entity)** 를 뜻합니다.

이와 같은 일을 하는 것을 **어휘분석기(lexical analyzer)** 혹은 **스캐너(scanner)** 라고 합니다.

토큰은 `BEGIN`, `PROGRAM`, `IF` 등과 같은 프로그래밍 언어의 **예약어(reserved word)** 나 `3`,`7` 또는 `2.5E + 01`과 같은 **상수**, `+`, `*`, `=` 과 같은 **연산자(operator)** 와 프로그래머가 정의한 **식별자(identifier)** 와 `괄호`나 `따옴표`, `세미콜론(;)` 등과 같은 **구분자(delimiter)** 등이 있습니다.

예를 들어 다음과 같은 문장을 읽어 들였다고 합시다.

**`ABC:=E * 3.14+ABC/E;`**

어휘분석 단계에서는 **`ABC`, `:=`, `E`, `*`, `3.14`, `+`, `ABC`, `/`, `E`, `;`** 의 10개의 토큰으로 분리하며, 어휘분석 단계에서의 출력은 이와 같은 일련의 토큰들이 된다.

이러한 토큰들은 **토큰번호**와 **토큰값**으로 구성되며, 컴파일러의 다음 단계인 **구문분석 단계**의 입력이 된다.

### 2. 구문분석(syntax analysis) 단계.

**구문분석** 혹은 **파싱(parsing)** 이라고도 하며, 어휘분석 단계의 결과인 **토큰들**을 **입력**으로 받아, 이 **토큰들**의 **열(cloumn)** 이 올바른 **문장구조**를 갖고 있는지를 검사합니다.

**구문이란 문장구조란 뜻으로 구문분석은 문장구조가 올바른지를 분석한다는 뜻이 됩니다.**

어휘분석 단계에서 어휘를 정의한 문법이 필요했던 것처럼 **구문분석 단계**에서도 **문장구조를 정의한 문법이 필요합니다.**

**구문분석 단계에서 하는 일**은 토큰들의 열이 전체적으로 문장을 정의한 문법에 맞는지를 분석하는 것인데, 올바른 문장에 대해서는 그 문장에 대한 구문구조(syntactic structure)를 만들어 출력하고, 올바르지 않은 문장에 대해서는 오류메세지(error message)를 출력합니다.

또한 이처럼 구문분석을 담당하는 것을 **구문분석기(syntax analyzer)** 혹은 **파서(parser)** 라고 합니다.

여기에서 구문구조는 토큰들을 **단말노드(terminal node)** 로 하는 **트리(tree)** 형태로 표현되는데, 이 트리를 **파스트리(parse tree)** 라고 합니다.

아래 그림은 치환문 **`ABC:=E * 3.14 + ABC/E`** 에 대한 파스트리입니다.

<img src = "https://github.com/devKobe24/images/blob/main/CPDD-11.png?raw=true"></br>

이와 같은 파스트리는 중간코드 생성 단계에서 이용됩니다.

일반적으로 파스트리는 위에서 보는 그림과 같이 불필요한 정보인 식별자, 숫자, 식 등이 있어서, 기억공간을 낭비하고 컴파일러의 속도를 떨어트립니다.

따라서 **불필요한 정보를 제거**하고, 다음 단계에서 **꼭 필요한 정보만으로 구성된 트리** 를 만들 수 있는데, 이것을 **구문트리(syntax tree 또는 abstract syntax tree)** 라고 합니다.

파스트리를 구문트리로 만들면 아래 그림과 같습니다.

<img src = "https://github.com/devKobe24/images/blob/main/CPDD-12.png?raw=true"></br>

### 3. 의미분석(semantic analysis) 단계.

**구문분석 단계의 결과인 구문트리가 어떠한 의미가 있고 어떠한 기능을 하는지 분석하고, 이러한 기능이 올바르게 수행될 수행될 수 있도록 환경을 조성하는 일을 합니다.**

그리고 이와 같은 일을 담당하는 것을 **의미분석기(semantic analyzer)** 라고 합니다.

여기서는 **구문트리**를 보며 **산술식**과 각 문장의 **연산자(operator)** 및 **피연산자(operand)** 를 **인식**하고 **유형검사(type checking)** 등을 합니다.

**유형검사**란 각 **연산자들이 원시 프로그램 규칙에 의해 허용된 피연산자를 가졌는지를 검사**하는 것을 뜻합니다.

예를 들면, 대부분의 프로그래밍 언어에서는 실수가 배열(array)의 첨자로 사용되는 것을 허용하지 않습니다.

이 경우 의미분석기는 오류임을 지적합니다.

또한 어떤 언어에서는 피연산자의 다양성을 허용하기도 합니다.

예를 들면 정수와 실수의 혼합형 연산을 허용하는데, 이때 의미분석기는 연산을 실행하기 전에 정수를 실수로 바꿔 주는 작업을 합니다.

### 4. 중간코드 생성(intermediate code generation) 단계.

**구문분석 단계에서 만들어진 구문트리를 이용하여 코드를 생성하거나 한 문법 규칙이 reducee될 때마다 구문지시적 변환(syntax-directed translation)으로 이루어집니다.**

**구문지시적 변환은 문법규칙이 reduce될 때 그 규칙에 알맞은 코드 생성 루틴을 부름으로써 중간코드를 생성합니다.**
그리고 중간코드 생성을 담당하는 도구를 **중간코드 생성기(intermediate code generator)** 라고 합니다.

앞에서 제시한 예를 보고 중간코드 열이 어떻게 생성되는지 살펴봅시다.

치환문 **`ABC:=E * 3.14+ABC/E`** 는 구문분석에서 얻어진 파스트리에 의하여 다음과 닽은 중간코드 열을 얻습니다.

<img src = "https://github.com/devKobe24/images/blob/main/CPDD-13.png?raw=true"></br>

이 방법은 중간언어의 표현방법 중 쿼드러플(quardruple) 코드 방법으로 표현한 것입니다.

여기에서 **`(*, E, 3.14, T₀)`** 는 **`E * 3.14`** 의 연산결과를 **`T₀`** 에 넣는 것을 의미합니다.

### 5. 코드최적화(code optimization) 단계.

**여기서는 코드를 좀 더 효율적으로 만들어 코드 실행 시 기억공간이나 실행시간을 절약하기 위한 단계입니다.**

**이 단계는 선택적 단계로 생략**되는 경우도 있지만, 요즘은 **RISC(Recude Instruction Set Computer)** 와 같은 컴퓨터 구조의 특성을 활용하기 위하여 **최적화 단계**를 많이 사용하고 있습니다.

최적화는 그 방법에 따라 여러 가지로 나눌 수 있는데, **지역최적화(local optimization 또는 peephole optimization)** 와 **전역최적화(global optimization)** 로 나눌 수 있고, **단일문**에서의 **최적화와 루프(loop)** **문장**에서의 **최적화**로 나눌 수도 있습니다.

또한 실행속도 면에서의 최적화와 기억장소 절약 면에서의 최적화 등으로 나눌 수도 있습니다.

**지역최적화란 부분적인 관점에서 일련의 비효율적인 코드들을 구분해 내고, 좀 더 효율적인 코드로 수정하는 방법입니다.**

여기에는 중복된 LOAD, STORE 명령문 제거, 불필요한 코드의 제거, 제어흐름의 최적화, 식(expression)의 대수학적 간소화(algebraic simplication), 연산의 세기경감(strength reduction), 상수전파(constant folding, constant propagation), 복사전파(copy propagation), 공통부분식(common subexpression) 제거, 결합변형 등이 있습니다.

**전역최적화는 지역최적화와는 달리 부분적인 관점이 아니라, 전체적인 관점에서 좀 더 효율적인 코드로 수정하는 방법입니다.**

여기에는 코드이동(codemotion), 귀납변수(induction variable) 최적화, 루프융합(loop fusion 혹은 loop jamming), 루프전개(loop unrolling) 등이 있습니다.

### 6. 목적코드 생성(code generation) 단계.

**컴파일 과정의 마지막 단계로 연산을 수행할 레지스터를 선택하거나 자료에 기억장소의 위치를 정해 주며, 실제로 목적기계어에 대한 코드를 생성하는 단계입니다.**

**이 과정에서는 중간코드 생성 단계에서 만들어진 중간코드들을 기계명령어(machine instrucation)로 바꾸어 주는 역할을 합니다.**

---

# 💯 마무리.

이상에서 본 바와 같이 컴파일 과정은 6단계로 이루어지며, 이것과 관련지어서 기호표 관리와 오류처리가 있습니다.

기호표는 원시 프로그램에 나타난 모든 자료에 대한 정보를 저장하는 데 사용되며, 이는 추후에 정리하도록 하겠습니다.

또한 컴파일하는 과정에서 오류가 발생하면 오류를 처리해 주어햐 합니다.
