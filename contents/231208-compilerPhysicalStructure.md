# 컴파일러의 물리적 구조(1) 🤿

[컴파일러의 논리적 구조](https://github.com/devKobe24/CompilerDeepDive/blob/main/contents/231202-logicalOrganization.md)애 대하여 살펴보았습니다.

논리적 구조라 함은 컴파일러가 해야 할 일은 이러이러한 논리적 요소로 나누어 생각할 수 있다는 의미이지만, 실제 컴파일러에서는 꼭 이과 같이 구성되는 것은 아닙니다.

예를 들면, 어휘분석과 구문분석에 대해 어떤 '컴파일러 1'에서는 우선 어휘분석 루틴이 작동하여, 
원시 프로그램 전부를 토큰의 열로 변환시킨 다음, 구문분석 루틴을 호출(call)하는데, 
다른 '컴파일러 2'에서는 구문분석 루틴이 먼저 작동하여 어휘분석 루틴을 부프로그램으로 호출하기도 합니다.

이처럼 컴파일러의 논리적 구조를 실제로 구현하는 경우, 그 물리적 구조는 논리적 구조와 반드시 일치하지 않습니다.

컴파일러의 구현에서는 이처럼 여러 단계를 모아서 하나의 모듈로 묶을 수 있는데, 이것을 패스(pass)라고 합니다.

앞에서 말한 '컴파일러 1'에서는 어휘분석 루틴과 구문분석 루틴이 각각 다른 패스에 속하고, '컴파일러 2'에서는 하나의 패스에 어휘분석 단계와 구문분석 단계를 구현한 것입니다.

따라서 컴파일러는 이러한 패스에 의하여 구현되는데, 아래 그림에서는 패스(pass)로 구성된 컴파일러의 물리적 구조를 보여줍니다.

<img src = "https://github.com/devKobe24/images/blob/main/CPDD-14.png?raw=true"></br>

현재 많이 사용하는 컴파일러 구현방법으로는 크게 두 가지가 있습니다.

하나는 1-패스 컴파일러(one-pass compiler)이고, 다른 하나는 2-패스 컴파일러(two-pass compiler)입니다.

1-패스 컴파일러는 초창기에 컴파일러를 만들 때 사용했던 방법으로, 컴파일러의 전 과정을 하나의 패스로 구현하는 방법이고, 2-패스 컴파일러는 컴파일러의 구성을 중간코드를 기점으로 하여, 앞 단계를 전반부(front-end), 뒤 단계를 후반부(back-end)로 구성하는 방법입니다.

1-패스 컴파일러는 컴파일러 이론이 정립되지 않은 초창기에 설계된 컴파일러로 원시 프로그램을 중간코드 생산 없이 목적코드로 직접 번역하였으며, 그 후 컴파일러 설계에 대한 이론이 정립되어 감에 따라 점차 번역단계가 세분화되어 컴파일러를 여러 모듈로 나누어서 설계할 수 있게 되었습니다.

이에 따라 각 모듈을 연결시켜 주는 중간코드가 필요해졌으며, 최근에는 중간코드의 선정과제가 컴파일러 설계에 큰 몫을 담당하게 되었습니다.

이 중 2-패스 컴파일러는 어휘분석, 구문분석, 중간코드 생성을 전반부로, 코드최적화와 목적코드 생성을 후반부로 나누는 방법입니다.

1-패스 컴파일러는 전진분기(forward jump)의 처리를 위해 빈칸으로 남겨두었다가 그 정보를 얻었을 때 채워 넣는 백패칭(backpatching)이 필요하나, 직접 그 기계에 맞는 코드로 변환시킬 수 있기 때문에 효율성이 좋고, 실행 속도가 빠르다는 장점이 있습니다.

반면에 2-패스 컴파일러는 코드로 직접 번역하지 못하기 때문에 기계코드 표현에 제약을 받고 실행속도가 느리다는 단점이 있습니다.

하지만 컴파일러를 기능적으로 독립된 여러 모듈로 구성할 수 있기 때문에 이식성(portability)이 좋고,
중간코드를 이용한 최적화에 따라 기계와 독립적인 최적화가 가능하며,
하나의 패스가 사용했던 공간을 다시 사용할 수 있으므로 기억장소를 절약할 수 있습니다.
일반적으로는 2-패스 컴파일러를 사용하고 있습니다.

### 🍗 문장 뜯어 먹기 냠냠(1)

> 예를 들면, 어휘분석과 구문분석에 대해 어떤 '컴파일러 1'에서는 우선 어휘분석 루틴이 작동하여, 
원시 프로그램 전부를 토큰의 열로 변환시킨 다음, 구문분석 루틴을 호출(call)하는데, 
다른 '컴파일러 2'에서는 구문분석 루틴이 먼저 작동하여 어휘분석 루틴을 부프로그램으로 호출하기도 합니다.

🙋‍♂️ 이 문장은 두 가지 다른 컴파일러의 작동 방식을 설명합니다.

'컴파일러 1'에서는 어휘분석(lexical analysis)이 먼저 수행되어 소스 코드를 토큰의 열로 변환한 후, 이 결과를 구문분석(syntax analysis)단계로 넘깁니다.

반면에, '컴파일러 2'에서는 구문분석이 먼저 시작되며, 필요할 때 어휘분석을 부프로그램(subprogram)으로 호출합니다.
이는 컴파일러 설계에 따라 어휘분석과 구문분석의 순서와 상호 작용 방식이 다를 수 있음을 보여줍니다.

### 🤔 어휘분석(lexical analysis)가 무엇인가요?

어휘분석은 컴파일 과정의 첫 단계로, 소스 코드를 읽어서 기본적인 요소인 '토큰(token)'으로 나누는 과정입니다.
토큰은 식별자, 키워드, 연산자, 구분자 등과 같은 의미 있는 최소 단위입니다.
예를 들어, **`int x = i;`** 이라는 코드에서 **'int', 'x', '=', ';'** 각각이 토큰입니다.

### 🤔 구문분석(syntax analysis)는요??

구문분석은 어휘분석을 통해 생성된 토큰의 열을 분석하여 소스 코드의 구조를 이해하는 과정입니다.
이 단계에서는 토큰들이 어떻게 조합되어 의미있는 문장이나 표현을 이루는지 파악합니다.
예를 들어, 괄호의 짝이 맞는지, if 문이 올바른 구문으로 구성되었는지 등을 검사합니다.

### 🤔 부프로그램(subprogram)이란?

부프로그램은 컴퓨터 프로그램 내에서 특정 작업을 수행하는 독립적인 코드 부분입니다.
이는 메인 프로그램으로부터 호출되어 특정 기능을 실행한 다음, 결과를 메인 프로그램에 반환합니다.
예를 들어, 함수나 메서드는 부프로그램의 예시입니다.

### 🤔 '토큰의 열로 변환한다'라는 것의 의미는 무엇인가요?

'토큰의 열로 변환한다'는 것은 소스 코드를 의미 있는 최소 단위인 토큰들의 순서적 나열로 바꾸는 것을 의미합니다.
이 과정에서 프로그램 코드는 단순한 문자열에서 분석 가능하고 의미를 가지는 구조(토큰의 열)로 변환됩니다.
이 토근의 열은 다음 단계인 구문분석에서 프로그램의 구조를 이해하는 데 사용됩니다.

### 🤔 컴파일러 프론트엔드가 뭐에요?

🙋‍♂️ 컴파일러는 크게 두 부분으로 나뉩니다.
프론트엔드와 백엔드.

1️⃣ **컴파일러 프론트엔드** 
프로그래밍 언어로 작성된 소스 코드를 읽고 분석하는 컴파일러의 초기 단계입니다.
프론트엔드의 주요 작업은 소스 코드의 구문 분석(syntax analysis), 의미 분석(semantic analysis), 그리고 중간 코드 생성입니다.
이 과정에서 프론트엔드는 소스 코드의 올바른 구문과 의미를 확인하고, 이를 일반화된 중간 표현(Intermediate Representation, IR)으로 변환합니다.
이 중간 표현은 백엔드에서 처리될 수 있는 형식입니다.

2️⃣ **컴파일러 백엔드**
프론트엔드에서 생성된 중간 표현을 받아, 기계 코드나 다른 저수준 언어로 변환하는 단계입니다.
백엔드는 중간 코드를 최적화하고, 특정 하드웨어 아키텍처에 맞게 코드를 생성합니다.

### 🍗 문장 뜯어 먹기 냠냠(2)

> 1-패스 컴파일러는 컴파일러 이론이 정립되지 않은 초창기에 설계된 컴파일러로 원시 프로그램을 중간코드 생산 없이 목적코드로 직접 번역하였습니다.

🙋‍♂️ 이 문장을 하나씩 분석해 볼까요?

1️⃣ **1-패스 컴파일러.**
이는 소스 코드를 단 한 번의 통과(pass)로 컴파일하는 컴파일러를 의미합니다.
즉, 프로그램의 각 부분을 한 번만 읽고 처리하는 방식입니다.

2️⃣ **컴파일러 이론이 정립되지 않은 초장기에 설계된 컴파일러.**
1-패스 컴파일러가 초기 컴퓨터 과학 시대, 특히 컴파일러 설계와 관련된 이론이 아직 완전히 발전하지 않았을 때 개발되었음을 나타냅니다.

3️⃣ **원시 프로그램을 중간코드 생산 없이 목적코드로 직접 번역**
이는 1-패스 컴파일러가 사용자가 작성한 원시 프로그램(소스 코드)을 받아 중간 단계의 코드를 생성하지 않고 바로 기계어나 실행 가능한 코드(목적 코드)로 변환한다는 의미입니다.
다시 말해, 이 컴파일러는 소스 코드를 중간 표현 형태로 변환하는 과정 없이 직접 최종적인 실행 코드로 번역합니다.

🙋‍♂️ 요약하면, 이 문장은 초기 컴퓨터 과학 시대에 개발된 1-패스 컴파일러가 어떻게 작동하는지 설명하고 있으며, 이러한 컴파일러는 소스 코드를 단 한 번 읽어서 바로 실행 가능한 목적 코드로 변환하는 방식을 사용했습니다.

### 🤔 원시 프로그램(소스 코드, Source code)?? 우가우가!!

🙋‍♂️ 원시 프로그램, 또는 소스 코드란 프로그래머가 작성하는 프로그램의 원본 텍스트를 말합니다.
이는 컴퓨터 프로그래밍 언어로 작성된 코드로, 사람이 읽고 이해할 수 있는 형태입니다.
예를 들어, C, Java, Python, Swift 등과 같은 고수준 프로그래밍 언어로 작성됩니다.

### 🤔 오! 그럼 원시 프로그램의 의미는요?!

🙋‍♂️ 원시 프로그램의 의미는 다음과 같습니다.

1️⃣ **사람이 읽고 이해할 수 있습니다.**
원시 프로그램은 사람이 이해할 수 있는 명령어와 구문을 사용하여 작성됩니다.
이는 프로그래머가 로직을 구성하고 문제를 해결하는 데 사용하는 기본 도구입니다.

2️⃣ **컴퓨터가 직접 실행할 수 없습니다.**
원시 프로그램은 컴퓨터가 직접 실행할 수 없는 형태입니다.
컴퓨터는 기계어(0과 1의 이진 코드)만 이해할 수 있기 때문에, 
원시 프로그램은 컴파일러나 인터프리터를 통해 기계어로 변환되어야 합니다.

3️⃣ **프로그램 개발의 첫 단계.**
원시 프로그램은 소프트웨어 개발 과정에서의 첫 단계로, 프로그래머의 의도에 따라 알고리즘과 로직을 구현하는 단계입니다.

4️⃣ **수정과 유지 보수가 용이.**
원시 프로그램은 텍스트 형태로 되어 있어 수정과 유지 보수가 비교적 용이합니다.
프로그래머는 이 코드를 읽고, 수정하고, 확장할 수 있습니다.

🙋‍♂️ 결론적으로, 원시 프로그램은 프로그래밍 언어로 작성된 사람이 읽을 수 있는 코드로, 컴퓨터가 이해하고 실행할 수 있는 형태로 변환되기 전의 프로그램입니다.

### 🤔 목적 코드(Object Code)?

🙋‍♂️ 목적 코드(Object Code)는 프로그래밍 언어로 작성된 원시 코드(Source code)가 컴파일러나 어셈블러에 의해 변환된 후의 형태를 말합니다.

이 변환된 코드는 컴퓨터가 직접 실행할 수 있는 이전 형태의 코드로, 기계어나 바이트코드의 형태를 띱니다.

### 🤔 목적 코드의 의미?

1️⃣ **컴퓨터가 실행할 수 있는 형태.**
목적 코드는 컴퓨터의 CPU가 직접 이해하고 실행할 수 있는 기계어나, 가상 머신에서 해석될 수 있는 중간 표현(바이트 코드)입니다.

2️⃣ **컴파일 과정의 결과물.**
원시 코드가 컴파일 과정을 거쳐 기계가 이해할 수 있는 형태로 변환된 결과물 입니다.
이 과정에서 컴파일러는 소스 코드의 구문을 분석하고, 최적화를 수행하며, 실행가능한 코드로 변환합니다.

3️⃣ **직접 실행 가능 또는 링킹 필요.**
일부 목적 코드는 직접 실행할 수 있는 완전한 형태일 수 있으며,
다른 경우에는 여러 목적 코드 파일을 링커(Linker)를 통해 하나의 실행 파일로
결합해야 할 수도 있습니다.

4️⃣ **플랫폼 및 아키텍처 의존적**
목적 코드는 특정 플랫폼(예: Windows, Linux) 또는 특정 하드웨어 아키텍처(예: x86, ARM)에 맞춰져 생성됩니다.
따라서, 하나의 플랫폼에서 생성된 목적 코드가 다른 플랫폼에서는 실행되지 않을 수 있습니다.

🙋‍♂️ 결론적으로, 목적 코드는 프로그래밍 언어로 작성된 코드가 컴퓨터가 이해하고 실행할 수 있는 이진 형태의 코드로 변환된 것을 의미하며, 소프트웨어 개발 과정에서 중요한 단계를 나타냅니다.

### 🍗 문장 뜯어 먹기 냠냠(3)

> 1-패스 컴파일러는 전진분기(forward jump)의 처리를 위해 빈칸으로 남겨두었다가 그 정보를 얻었을 때 채워 넣는 백패칭(backpatching)이 필요하나, 직접 그 기계에 맞는 코드로 변환시킬 수 있기 때문에 효율성이 좋고, 실행 속도가 빠르다는 장점이 있습니다.

🙋‍♂️ 이 문장은 1-패스 컴파일러의 특징과 장점에 대해 설명하고 있습니다. 이 문장의 의미를 하나씩 뜯어볼까요?!

1️⃣ **1-패스 컴파일러.**
이는 프로그램의 소스 코드를 단 한 번의 통과(pass)로 컴파일하는 컴파일러를 의미합니다.
즉, 프로그램 코드를 한 번만 읽어서 처리합니다.

2️⃣ **전지분기(forward jump)의 처리.**
전진분기는 프로그램의 실행 흐름이 아직 컴파일되지 않은 미래의 지점으로 뛰어넘는 것을 말합니다.
1-패스 컴파일러에서는 이러한 전진분기 지점의 주소가 초기에는 불명확합니다.

3️⃣ **백패칭(backpatching)**
백패칭은 컴파일러가 뒤늦게 필요한 정보(예: 전진분기의 목적지 주소)를 얻었을 때, 이전에 미리 빈칸으로 남겨둔 부분을 채우는 과정입니다.
1-패스 컴파일러에서 이러한 방식이 필요합니다.

4️⃣ **직접 그 기계에 맞는 코드로 변환**
1-패스 컴파일러는 소스 코드를 바로 해당 컴퓨터의 기계어로 변환합니다.
이는 중간 코드를 생성하는 과정을 생략하기 때문에 효율적입니다.

5️⃣ **효율성과 실행 속도의 장점**
이러한 방식은 컴파일 과정이 빠르고, 생성된 기계어 코드의 실행 속도도 빠르다는 장점이 있습니다.
컴파일 과정에서의 시간 절약과 실행 시의 성능 향상을 의미합니다.

🙋‍♂️ 요약하면, 이 문장은 1-패스 컴파일러가 전진분기 처리를 위해 백패칭을 사용하며, 소스 코드를 직접 기계어로 효율적으로 변환하여 실행 속도를 개선한다는 점을 설명하고 있습니다.

### 🍗 문장 뜯어 먹기 냠냠(4)

> 2-패스 컴파일러를 기능적으로 독립된 여러 모듈로 구성할 수 있기 때문에 이식성(portability)이 좋고,
중간코드를 이용한 최적화에 따라 기계와 독립적인 최적화가 가능하며,
하나의 패스가 사용했던 공간을 다시 사용할 수 있으므로 기억장소를 절약할 수 있습니다.

🙋‍♂️ 이 문장은 2-패스 컴파일러의 특징과 장점을 설명하고 있습니다. 이 문장의 의미를 분석해봅시다!!

1️⃣ **기능적으로 독립된 여러 모듈로 구성.**
2-패스 컴파일러는 컴파일 과정을 두 단계로 나누어 처리합니다.
각 단계는 기능적으로 독립된 모듈로 구성되어 있으며, 이들 모듈은 각각의 특정 작업을 수행합니다.
이는 각 모듈이 서로 다른 작업에 집중할 수 있게 하며, 더 구조화된 접근 방식을 제공합니다.

2️⃣ **이식성(portability)이 좋음.**
각 모듈이 독립적이기 때문에, 2-패스 컴파일러는 다양한 하드웨어나 운영 체제에 쉽게 적용될 수 있습니다.
이는 컴파일러가 특정 플랫폼에 덜 의존적이게 하고, 다양한 시스템으로의 이식성을 향상시킵니다.

3️⃣ **중간코드를 이용한 최적화.**
2-패스 컴파일러는 중간코드(Intermediate code)를 생성하고 이를 이용해 최적화를 수행합니다.
이 중간코드는 하드웨어에 독립적이므로, 플랫폼에 구애받지 않는 최적화가 가능합니다.
이는 프로그램의 실행 효율성을 높일 수 있습니다.

4️⃣ **기억장소 절약.**
2-패스 컴파일러에서 한 패스가 완료된 후 그 패스가 사용했던 메모리 공간을 다음 패스에서 재사용할 수 있습니다.
이는 전체 컴파일 과정에서 필요한 메모리 사용량을 줄여줍니다.

🙋‍♂️ 요약하면, 이 문장은 2-패스 컴파일러가 각기 다른 기능을 하는 모듈로 구성되어 있어 이식성이 높고, 중간코드를 활용한 최적화를 통해 하드웨어의 독립적인 효율성을 달성하며, 메모리 사용의 효율성을 제공한다는 점을 설명하고 있습니다.
