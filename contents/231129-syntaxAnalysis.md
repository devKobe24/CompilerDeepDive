# 구문분석의 종류 🤿

모든 프로그래밍 언어는 프로그램이 잘 완성될 수 있는 구문구조를 묘사하는 규직을 가지고 있습니다.

예를 들어, 파스칼 프로그램은 블록(block)들로 만들어지고, 블록은 문장(statement)들로 이루어지며, 그 문은 식(expression)들로부터 만들어지고, 그 식은 토큰들로부터 만들어집니다.

이와 같이 구문구조가 주어진 규칙에 잘 맞는지, 맞지 않는지를 검사하는 것을 **구문분석(syntax analysis)** 혹은 **파싱(parsing)** 이라고 합니다.

즉, **구문분석**이란, 문장 w를 입력으로 받아서, 만약 w가 정의된 문법의 문장이라면 w에 대한 **파스트리(parse tree)** 를 생성하고 w가 정의된 문법의 문장이 아니라면 오류메세지를 내는 작업을 말합니다.

이러한 구문분석을 담당하는 도구를 **구문분석기(syntax analyzer, parser)** 라고 합니다.

일반적으로 **구문분석**의 **출력**으로 생성되는 트리는 **유도트리(derivation tree)** 와 같은 모양을 갖는데 **유도과정**을 나타낼 때에는 **유도트리**라 하고, 이 트리가 **구문분석기**에 의해 **생성**될 때에는 **파스트리(parse tree)** 라고 합니다.

**구문분성 방법**은 **파스트리**를 어떤 **순서**로 만들어 가느냐에 따라 크게 **top-down 방법**과 **bottom-up 방법** 두 종류로 나눌 수 있습니다.

**top-down 방법**은 **루트노드(root node)** 로부터 **시작**하여 **터미널 노드**로 만들어 나가는 **반면**에, **bottom-up 방법**은 **터미널 노드**로부터 **루트노드**를 향하여 만들어 나갑니다.

즉, 시작기호로부터 출발하여 정의된 문법의 **규칙(rule)들을 적용**하여 유도에 의한 주어진 **문자열을 찾아가는 방법**이 **top-down**이고, 반대로 입력된 문자열에서 **reduce**에 의해 **시작기호를 찾아가는 방법**이 **bottom-up** 방법입니다.

유도하는 관점에서 보면 이것은 각각 **좌돤유도**와 **우단유도**가 됩니다.

# 1️⃣ 구문분석기의 종류와 역사.

초기의 컴파일러에서 **구문분석 방법**이 **문제**가 되었던 것은 **산술식**에 대한 것이였습니다.
**산술식 외의 부분**은 거의 **정해진 형태**로 되어 있으나, **산술식의 형태**는 **다양**했기 때문입니다.

최조의 **FORTRAN 컴파일러**에서 취한 **방법**은 **연산자**의 **전후**에 적당한 개수에 **괄호**를 붙여, **안쪽 괄호**에 **둘러싸인 부분**부터 **처리**해 나가는 것이였습니다.

그러나 이 **방법**은 **괄호**를 붙이거나 **안쪽 괄호**를 **찾기 위해**서 **주어진 산술식**을 몇 번이고 **검사(scanning)** 하게 되어 **효율**이 많이 **떨어졌습니다.**

그리하여 **산술식**을 **좌에서 우**로 **한 번만 검사**하는 **구문분석**을 하는 방법이 1960년 새멜슨(Semelson)과 바우어(Bauer)에 의해 고안되었습니다.

그것은 **산술식**을 **좌**로부터 **검사**하면서 **먼저 실행**해서는 **안 되는 것**은 **일시적**으로 **스택**에 **쌓아** 놓고, **다음**에 **읽어 들인 연산자**와 **스택의 top에 있는 연산자**의 **비교**에 의해 **다음 동작을 결정** 하는 것입니다.

그 **동작**들은 **스택**의 top의 연산자 **Tᵢ**와 읽어 들인 연산자 **Tⱼ**의 조합에 대한 동작 **Aᵢⱼ**의 행렬로 표현하면 됩니다.
이 행렬을 **전이행렬(transition matrics)** 이라고 하며 **파싱표**를 뜻합니다.

이 방법은 1963년 플로이드(Flyod)에 의해 일반화되었는데, 이를 **연산자순위(operator precedence)** 에 따른 **구문분석 방법**이라 하고 이런 문법을 **연산자순위 문법**이라고 합니다.

그러나 **연산자순위 문법**으로는 **보통**의 산술식은 표현할 수 있으나, **일반적인 프로그램 언어**를 다 표현할 수는 **없습니다.**

그래서 보다 **넓은** 표현능력을 가진 문법으로 단순순위(simple precedence), 확장순위(extended precedence), 한정순위(weak precedence), 혼합순위(mixed strategy precedence), LR(k) 문법들이 제시되었으며, **현재 실용화되어 있는 문법**은 **LR(1)** 입니다.

위에서 말한 모든 문법은 주어진 문자열로부터 **reduce**에 의해 시작기호를 찾아가는 **bottom-up 방법**에 속하며, **bottom-up 방법**은 가장 **많이** 사용하는 **구문분석 방법**입니다.

이와는 다르게 주어진 문법을 그대로 사용해 시작기호로부터 주어진 문자열을 찾아가는 **top-down 방법**에는 **재귀적(recursive)** 프로시저를 이용하는 **recrusive-descent 구문분석 방법**이 있으나, 이 방법은 검사된 입력을 몇 번이고 다시 검사하는 **backtracking의 문제**를 가지고 있습니다.

그래서 **backtracking을 방지**하기 위하여 **LL(k) 문법을 사용**하게 되었습니다.

지금까지의 설명을 정리한 것이 아래의 표입니다.

<img src = "https://github.com/devKobe24/images/blob/main/CPDD-6.png?raw=true"></br>
