# 컴파일러의 물리적 구조(2) 🤿

- [컴파일러의 물리적 구조(1)](https://github.com/devKobe24/CompilerDeepDive/blob/main/contents/231208-compilerPhysicalStructure.md)

컴파일러를 구현하는 것은 일반 소프트웨어의 구현과 비슷합니다.

다음은 컴파일러를 구현시 주의사항입니다.

**(1) 설계 문제**<br>
각각의 패스에 어떠한 기능을 할당하고 패스를 전부 몇 개로 할 것인지를 결정하는 등의 설계상 문제입니다.<br>
그것들을 결정하는 근거 및 조건이 되는 것은 컴파일러의 논리적 구조, 컴퓨터 자원, 사용자의 요구사항, 컴파일러를 개발하는 인적자원 등입니다.<br>
우선 컴파일러의 논리적 구조는 필연성에서 얻은 것이므로, 물리적 구조는 될 수 있는 한 그것에 맞추는 것이 좋습니다.<br>
즉, 어휘분석, 구문분석, 의미분석, 중간코드 생성, 코드최적화, 목적코드 생성 등의 단계를 하나로 총괄해서 1-패스로 만들던가 어휘분석에서부터 중간코드 생성까지를 하나의 패스로 묶어서 2-패스로 만들던가, 아니면 더 세부적으로 여러개의 패스로 만들던가 해야 합니다.<br>
아니면 더 세부적으로 여러개의 패스로 만들던가 해야 합니다.<br>
이것은 구현하는 사람이 주변조건 등을 고려해서 만들어야 하지만, 되도록이면 컴파일러의 여섯 가지 단계를 갖추어야 합니다.<br>

**(2) 컴퓨터 자원**<br>
컴파일러에 가장 큰 영향을 미치는 것은 기억용량(storage)입니다.<br>
하나의 패스가 실행되고 있을 때는 그 패스의 루틴(routine)과 그 패스에서 참조하는 정보의 표가 모두 주기억장치에 있지 않으면 효율이 떨어집니다.<br>
따라서 주기억장치의 용량이 작으면, 패스의 수를 늘려서 패스 각각의 크기를 작게 하지 않으면 안됩니다.<br>
즉 1-패스 컴파일러보다는 2-패스 컴파일러로, 2-패스 컴파일러보다는 3-패스 컴파일러로 만듭니다.<br>
그러나 최근 컴퓨터들은 대부분 가상기억(virtual memory)장치 방식을 사용하므로, 실제 용량이 컴파일러의 설계상에 큰 제약이 되지는 않는다고 할 수 있습니다.<br>
그렇다고 해도 가상기억장치는 실제 기억장치보다 실행효율이 떨어지므로 패스가 너무 크면 안됩니다.<br>
또한 작은 마이크로컴퓨터(microcomputer)의 경우에는 디스크와 같은 보조 기억장치가 없는 것이 있는데, 그러한 경우는 하나의 패스만으로 구성해야 합니다.<br>
그 밖에 운영체제나 연결편집기(linkage editor)의 기능, 컴파일러의 메타언어 등의 소프트웨어 시스템도 고려해야 할 중요한 자원입니다.<br>

**(3) 사용자의 요구사항**<br>
사용자에 따라 프로그램 실행시간을 중요시하는 경우도 있고, 컴파일하는 시간을 중요시하는 경우도 있으며, 오류가 발생할 경우 디버그(debug)하는 기능을 중요시하는 경우도 있습니다.<br>
또한 컴파일러의 크기, 기억장치의 용량 등도 주요 고려대상입니다.<br>
하지만 이런 것들을 모두 만족시키는 컴파일러는 없습니다.<br>
그러나 예를 들어서 컴파일하는 시간을 중요시하는 경우를 생각해봅시다.<br>
이 경우에는 컴파일러를 설계할 때, 큰 기억용량을 사용하여 한번에 컴파일 할 수 있도록 설계해야 합니다.<br>
반면, 오류가 발생하고 디버그 기능을 중요시하는 경우를 살펴봅시다.<br>
이 경우에는 컴파일하는 시간보다는 컴파일하는 과정에서 생겨나는 모든 정보를 간직하게 하고 후에 오류가 발생할 경우 디버그를 편하게 할 수 있도록 설계해야 합니다.<br>

**(4) 컴파일러를 개발하는 인적자원**<br>
일반적으로 컴파일러를 만드는 것은 많은 시간과 많은 인력이 필요합니다.<br>
그래서 컴파일러 개발에 얼마만큼의 인력을 동원할 수 있는가, 얼마만큼의 시간을 쓸 수 있는가에 따라 설계도 영향을 받습니다.<br>
소프트웨어 개발에 필요한 시간과 질은 개발에 참여하는 사람의 자질이나 경험에 크게 좌우됩니다.<br>
능력이 모자라면 모험은 피해야 합니다.<br>
많은 인력을 동원할 경우에는 각자가 제멋대로 생각하지 않도록 설계상에 통일을 기하는 것이 중요합니다.<br>
기본설계는 중심적인 사람이 하는 것이 좋은데, 각 패스의 기능과 레지스터 간에 주고받는 중간언어와 표의 정보를 혼자 설계한 후에 각 패스의 내부설계를 다음 단계의 사람이 분담하도록 하는 것이 좋습니다.<br>
